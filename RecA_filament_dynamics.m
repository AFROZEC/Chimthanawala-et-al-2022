

%% Compiled analysis tool
% This script is written to determine various parameters such as: 1. filament length - under variable name: 2. total intensity of filament- under variable name: 3. position occupancy of filament- under variable name: The input data
%is from two sources: an image file for analysis and the respective analysis file from oufti. The "mesh" data generated by oufti is utilized to segment the cell from the image and further analysis is carried out. Each section (demarcated
% by '%%') has a brief description of the fuctions carried out in the section.
%
% Author:- Meghana B and Afroze
% Date:- 27/3/2020 (DD/MM/YY)
%%
clear; clc; %close all;

%% set the folder path of the image and .mat analysis file
 
size_quad = double.empty;
quad_occupancy = double.empty;
temp_fil = zeros(size(quad_occupancy));
temp_quad = zeros(size(quad_occupancy));
value1 = uint16.empty;
value2 = uint16.empty;
intensity_vals1 = zeros(size(value1));
intensity_vals2 = zeros(size(value2));
value = 0.92; %threshold value
t=1;
tt=1;

%%
for z = 2;
    c=z+0;
    main_folder = '\\storage.ncbs.res.in\ab_lab\Current members\Afroze\Papers\RecN_2021\Data\Ori_RecA_1min_PD\wt\20200123\RecA_1min_PD_400ms\AC245_001\split\loaded\';
    path = [main_folder, 'crop_', num2str(z),'\'];
    im_file =['C2-crop_',num2str(z),'.tif']; %name of image file
    file = ['RecA_+N_PD_1min_crop_',num2str(c),'.mat']; %name of oufti analysis file

    %% variables:
    total_intensity_profile = uint16.empty; %#ok<*NASGU>
    imagesc_file = uint16.empty;
    
    %% Load the .tif file stack
    
    FileTif = [path im_file];
    InfoImage=imfinfo(FileTif);
    Image_width = InfoImage(1).Width;
    Image_height = InfoImage(1).Height;
    Number_Images = length(InfoImage);
    FinalImage=zeros(Image_height,Image_width,Number_Images,'uint16');
    FinalImage_1=zeros(Image_height,Image_width,Number_Images,'uint16');
    FinalImage_2=zeros(Image_height,Image_width,Number_Images,'uint16');
    for i=1:Number_Images
        FinalImage(:,:,i)=imread(FileTif, i);
    end

    %% Load the .mat file containing the segmentation data of the entire stack
    load([path file]);

    %% Generate a second .tif stack containing only segmented cell
    [~,im_data] = find(cellListN);
    quad_occupancy = double.empty(max(im_data),0);
    FinalImage_segmented = zeros(Image_height,Image_width,Number_Images,'uint16');
    for i=1:Number_Images
        cell_content = cellList.meshData(1,i);
        if length(cell_content{1,1})>0
            mesh_val = cell_content{1,1}{1,1}.mesh;
            X = [mesh_val(:,1);mesh_val(length(mesh_val):-1:1,3)];
            Y = [mesh_val(:,2);mesh_val(length(mesh_val):-1:1,4)];
            BW = roipoly(FinalImage(:,:,i),X,Y);
            FinalImage_segmented(:,:,i) = FinalImage_segmented(:,:,i) + uint16(BW).*FinalImage(:,:,i); % segmented cell image only
        end
    end
    total_intensity_profile = single.empty;
    var6 = [im_data(1), ceil(median(im_data))];
    for i = im_data(1): ceil(mean(var6))
        im = FinalImage_segmented(:,:,i);
        total_intensity_profile = [total_intensity_profile; im(:)];
    end
    
    tip = double(total_intensity_profile);
    [f, x] = ecdf(tip);
    thresh_1 = value; y = x(and(f>thresh_1,f<1));
    thresh = y(1);
    %% Generating a stack of threshold images
    FinalImage_thresholded = zeros(Image_height, Image_width, Number_Images, 'uint16');
    for i=1:Number_Images
        cell_content = cellList.meshData(1,i);
        if length(cell_content{1,1}) > 0
            im = FinalImage_segmented(:,:,i);
            im(im<thresh)=0;
            FinalImage_thresholded(:,:,i) = im; %contains only the filament
        end
    end
    %% PART 1: orienting the curved and saving the images in im3
    % This is done to ensure the filament length values are more reliable; The c-shaped caulobacter cells are aligned with respect to an imaginary middle line passing
    % through the center of the cell. Final straigtened image can be viewed in part 3
    
    differences = single.empty;
    newmaskimg = uint16.empty;
    im2 = uint16.empty;
    im3 = zeros(size(im2(:,:,:)));
    val = 1; %initial coordinate value
    
    for image_num = 1:Number_Images
        if isempty(cellList.meshData{1, image_num})
            continue
        else
            x1 = cellList.meshData{1, image_num}{1, 1}.mesh(:,1); %meshes from oufti
            y1 = cellList.meshData{1, image_num}{1, 1}.mesh(:,2);
            a1 = cellList.meshData{1, image_num}{1, 1}.mesh(:,3);
            b1 = cellList.meshData{1, image_num}{1, 1}.mesh(:,4);
            
            for temp7 = 1:length(y1) %width of cell
                differences(temp7,1) = sqrt(((a1(temp7)-x1(temp7))^2)+((b1(temp7)-y1(temp7))^2));
            end
            rect_x = length(y1);
            rect_y = double(ceil(max(abs(differences)))); %max width of cell
            img = zeros(rect_y, rect_x);
            imgLogical = logical(img);
            img(ceil(rect_y/2), ceil(rect_x/2))=1;
            se1 = strel('rectangle',[rect_x rect_y]); %[rows, cols]
            im2 = imdilate(img,se1); %creates a rectangle with dimensions of cell
            im3(1:size(im2,1),1:size(im2,2),image_num) = im2;
            
            %%
            %modify the follwing to read the cell until halfway and then change the orientation in which its rotated maybe 2 for loops?
            
            for val = 1:(length(y1)-1) % refer comment above
                newimg = FinalImage_segmented(:,:,image_num);
                % pos = alternating x and y values;
                pos = double([x1(val) y1(val) a1(val) b1(val) a1(val+1) b1(val+1) x1(val+1) y1(val+1) x1(val) y1(val)]);
                bw = ~poly2mask(pos(1:2:end), pos(2:2:end), size(newimg, 1), size(newimg, 2));  % 2D mask
                maskimg = newimg;
                maskimg(bw) = 0;
                tempmask = maskimg>0;
                stats2 = regionprops(tempmask, 'Orientation');
                stats2 = struct2cell(stats2);
                if isempty(stats2)
                    theta = 0;
                else
                    theta = stats2{1,1};
                end
                newmaskimg = imrotate(maskimg,-(theta));
                [im_row, im_col] = find(newmaskimg);
                row_span = unique(im_row); %how many rows the image spans
                col_span = unique(im_col);
                for var4 = 1:length(col_span)
                    im3(var4, val, image_num) = max(newmaskimg(:, col_span(var4)));
                end
            end
        end
    end
    
    %% PART 2: identifying the middle line
    temp_middle = double.empty;
    middle_value = zeros(size(temp_middle(:,:,:)));
    im3 = changem(im3,0,1); %to remove the 1's
    
    for image_num = 1: max(im_data) %size(im3, 3)
        [~, col1] = find(im3(:,:,image_num));
        cell_start = min(col1);
        cell_end = max(col1);
        temp_middle = unique(col1);
        middle_value(1:size(temp_middle,1),2,image_num) = temp_middle; %column values of middle line
        
        for temp1 = cell_start:cell_end
            [row2,~] = find(im3(:,temp1, image_num));
            middle_value((temp1-cell_start)+1,1, image_num) = ceil(median(row2)); %row values of middle line
        end
    end
    %% PART 3:
    % to alter the position of pixels in the segmented image wrt the
    % middle line passing through the image
    
    im3 = uint16(im3);
    temp6 = zeros(size(im3));
    
    for image_num = 1: max(im_data)
        temp3 = im3(:,:,image_num);
        mid_val_img = middle_value(:,:,image_num);
        [~,~,row4] = find(mid_val_img(:,1)); %x coordinates of middle line
        [~,~,col4] = find(mid_val_img(:,2)); %y coordinates of middle line
        [index_c4, ~] = find(col4);% index of col4:
        rect_y = size(temp3, 1);
        for temp4 = 1: max(index_c4)
            col3 = col4(temp4);
            [row3, ~] = find(temp3(:,col3));
            for temp5 = 1 :length(row3)
                if ceil(median(1:rect_y)) >  row4(temp4) % row4(temp4) is the coordinate for the middle line; compare each columns's middle value to
                    difference = ceil(rect_y/2)-row4(temp4); %row4(1,1) = middle row of 1st column
                    temp6(row3(temp5)+difference, col3, image_num) = temp3(row3(temp5), col3);
                    
                elseif ceil(median(1:rect_y)) <  row4(temp4)
                    difference =  (row4(temp4)) - ceil(rect_y/2);
                    temp6(row3(temp5)-difference, col3, image_num) = temp3(row3(temp5), col3);
                    
                elseif ceil(median(1:rect_y)) ==  row4(temp4)
                    difference = 0;
                    temp6(row3(temp5), col3, image_num) = temp3(row3(temp5), col3);
                end
            end
        end
    end
    temp6 = uint16(temp6);
    newtemp6 = permute(temp6,[2 1 3]); %creates a stack of segmented, aligned cells
    cols = size(temp6, 1)+1;
    cols2 = size(temp6,2);
    for var5 = 1:size(im3, 3)
        newtemp6(:,cols,var5) = zeros(cols2,1); %gap between cells
    end
    
    end
    %%
    total_intensity_profile_2 = double.empty;
    newtemp6_thresholded = uint16.empty; %changes for every sample
    for i=1: size(im3,3)%Number_Images
        tip_2 = [];
        im4 = newtemp6(:,:,i);
        total_intensity_profile_2 = [total_intensity_profile_2; im4(:)];
        tip_2 = double(total_intensity_profile_2);
        [f3, x3] = ecdf(tip_2);
        thresh_4 = value; y3 = x3(and(f3>thresh_4,f3<1));
        thresh3 =y3(1);
    end
    
   for i=1:max(im_data)%size(im3, 3)
        cell_content = cellList.meshData(1,i);
        if length(cell_content{1,1}) > 0
            im4 = newtemp6(:,:,i); %segmented straight image
            im4(im4<thresh3)=0;
            newtemp6_thresholded(:,:,i) = im4; %thresholded image
        end
    end
  %% sum intensity across rows from the newtemp6_threshold file

for i = 1:size(im3,3)%Number_Images
%     if sum(newtemp6_thresholded(:,:,21),2)>0
        d(1:size(newtemp6_thresholded,1),i) = sum(newtemp6_thresholded(:,:,i),2);
        e(1:size(newtemp6_thresholded,1),i) = d(:,i)>0;
        length_fil(i,1) = sum(e(:,i));
%     end
        
end

newRow = zeros(1,size(im3,3));
e_new = [newRow; e(:,:)];
e = double.empty;
e = e_new;

%% sum intensity across rows from the newtemp6
for i = 1:size(im3,3)%Number_Images
        d_full(1:size(newtemp6,1),i) = sum(newtemp6(:,:,i),2);
        total_int_cell(i,1) = sum(d_full(:,i));
end
%% to identify the row where the loaclization starts and ends 
%if there is a gap of 1 pixel between 2 localizations it is considered as 1
%localization
start = [0 0 1];
stop = [1 0 0];
start_index = NaN(size(im3,3),3);
stop_index = NaN(size(im3,3),3);
for i = 1:size(im3,3)%Number_Images
   if sum(e(:,i),1)>0
        k = (e(:,i))';
        g = strfind(k,start);
            if numel(g)==0
                start_index(i,1) = 1;
            elseif numel(g)==1
                start_index(i,1) = strfind(k,start)+2;
            elseif numel(g)==2
                start_index(i,1:2) = strfind(k,start)+2;
            else
                start_index(i,1:3) = strfind(k,start)+2;
            end
        h = strfind(k,stop);
            if numel(h)==0
                stop_index(i,1) = size(k,2);
            elseif numel(h)==1
                stop_index(i,1) = strfind(k,stop);
            elseif numel(h)==2
                stop_index(i,1:2) = strfind(k,stop);
            else
                stop_index(i,1:3) = strfind(k,stop);
            end
   end
end

%% to calculate length, QO and total intensity
% first localization information is placed in the column 1 and second
% localization in column 2
%for localization 1
for i = 1:size(im3,3)%Number_Images
    if stop_index(i,1)>0      
            fil_length_raw(i,1)=((stop_index(i,1)-start_index(i,1))+1);
            fil_length(i,1)=0.108*((stop_index(i,1)-start_index(i,1))+1);
            row_no(i,1) = ((start_index(i,1)+(fil_length_raw(i,1))/2));
            total_int(i,1)= sum(d(start_index(i,1):stop_index(i,1),i));
    end
end
%for localization 2
for i = 1:size(im3,3)%Number_Images
    if stop_index(i,1)>0  
        if stop_index(i,2)>0
                fil_length_raw(i,2)=((stop_index(i,2)-start_index(i,2))+1);
                fil_length(i,2)=0.108*((stop_index(i,2)-start_index(i,2))+1);
                row_no(i,2) = ((start_index(i,2)+(fil_length_raw(i,2))/2));
                total_int(i,2)= sum(d(start_index(i,2):stop_index(i,2),i));
        end
    end
end
%for localization 3
for i = 1:size(im3,3)%Number_Images
    if stop_index(i,1)>0  
        if stop_index(i,3)>0
                fil_length_raw(i,3)=((stop_index(i,3)-start_index(i,3))+1);
                fil_length(i,3)=0.108*((stop_index(i,3)-start_index(i,3))+1);
                row_no(i,3) = ((start_index(i,3)+(fil_length_raw(i,3))/2));
                total_int(i,3)= sum(d(start_index(i,3):stop_index(i,3),i));
        end
    end
end
row_no_new = round(row_no);
%% to calculate cell length
for i = 1:size(im3,3)%Number_Images
    if sum(e(:,i),1)>0
    d_cell_length(1:size(newtemp6,1),i) = sum(newtemp6(:,:,i),2);
    [y,~] = find(d_cell_length(:,i)>0,1,'last');
    length_cell(i,1) = y;
    end
end
cell_length = 0.108*length_cell;
%% to divide cell in 8 equal segments and detect position on RecA filamnet centroid in these segments
quad_occupancy = NaN(size(row_no_new,1),2);
%for first localization
for i = 1:size(row_no_new,1)
%     if sum(e(:,i),1)>0
    a = row_no_new(i,1);
    x = length_cell(i,1)/8;
    f = length_cell(i,1)*0.125;
        if a==0 % a = 0, when there's no filament
            quad_occupancy(i,1)= nan;
        elseif (a > 0) && (a <= x)
            quad_occupancy(i,1)=(f*1*0.125)/x;
        elseif (a >= x) && (a <= x*2)
            quad_occupancy(i,1)=(f*2*0.125)/x;
        elseif (a >= x*2) && (a <= x*3)
            quad_occupancy(i,1)=(f*3*0.125)/x;
        elseif (a >= x*3) && (a <= x*4)
            quad_occupancy(i,1)=(f*4*0.125)/x;
        elseif (a >= x*4) && (a <= x*5)
            quad_occupancy(i,1)=(f*5*0.125)/x;
        elseif (a >= x*5) && (a <= x*6)
            quad_occupancy(i,1)=(f*6*0.125)/x;
        elseif (a >= x*6) && (a <= x*7)
            quad_occupancy(i,1)=(f*7*0.125)/x;
        elseif (a >= x*7)
            quad_occupancy(i,1)=(f*8*0.125)/x;
        end
%     end
end

%for second localization
for i = 1:size(row_no_new,1)
        if size(row_no_new,2)>1
            if row_no_new(i,2)>0
                a = row_no_new(i,2);
                x = length_cell(i,1)/8;
                f = length_cell(i,1)*0.125;
                if a==0 % a = 0, when there's no filament
                    quad_occupancy(i,2)= nan;
                elseif (a > 0) && (a <= x)
                    quad_occupancy(i,2)=(f*1*0.125)/x;
                elseif (a >= x) && (a <= x*2)
                    quad_occupancy(i,2)=(f*2*0.125)/x;
                elseif (a >= x*2) && (a <= x*3)
                    quad_occupancy(i,2)=(f*3*0.125)/x;
                elseif (a >= x*3) && (a <= x*4)
                    quad_occupancy(i,2)=(f*4*0.125)/x;
                elseif (a >= x*4) && (a <= x*5)
                    quad_occupancy(i,2)=(f*5*0.125)/x;
                elseif (a >= x*5) && (a <= x*6)
                    quad_occupancy(i,2)=(f*6*0.125)/x;
                elseif (a >= x*6) && (a <= x*7)
                    quad_occupancy(i,2)=(f*7*0.125)/x;
                elseif (a >= x*7)
                    quad_occupancy(i,2)=(f*8*0.125)/x;
                end
            end
        end
end
%for 3rd localization
for i = 1:size(row_no_new,1)
        if size(row_no_new,2)>2
            if row_no_new(i,3)>0
                a = row_no_new(i,3);
                x = length_cell(i,1)/8;
                f = length_cell(i,1)*0.125;
                if a==0 % a = 0, when there's no filament
                    quad_occupancy(i,3)= nan;
                elseif (a > 0) && (a <= x)
                    quad_occupancy(i,3)=(f*1*0.125)/x;
                elseif (a >= x) && (a <= x*2)
                    quad_occupancy(i,3)=(f*2*0.125)/x;
                elseif (a >= x*2) && (a <= x*3)
                    quad_occupancy(i,3)=(f*3*0.125)/x;
                elseif (a >= x*3) && (a <= x*4)
                    quad_occupancy(i,3)=(f*4*0.125)/x;
                elseif (a >= x*4) && (a <= x*5)
                    quad_occupancy(i,3)=(f*5*0.125)/x;
                elseif (a >= x*5) && (a <= x*6)
                    quad_occupancy(i,3)=(f*6*0.125)/x;
                elseif (a >= x*6) && (a <= x*7)
                    quad_occupancy(i,3)=(f*7*0.125)/x;
                elseif (a >= x*7)
                    quad_occupancy(i,3)=(f*8*0.125)/x;
                end
            end
        end
end
%% save data in excel
xlFilename = strcat(main_folder, 'quadrant_occupancy_crop_', num2str(c),'.xls');
writematrix(quad_occupancy,string(xlFilename),'Sheet',1,'Range', 'A1');%segment in which RecA filament centroid is positioned
writematrix(row_no_new,string(xlFilename),'Sheet',1,'Range', 'F1');%pixel number of the RecA filament centroid along cell length
writematrix(fil_length,string(xlFilename),'Sheet',2,'Range','A1'); %filament data
writematrix(cell_length,string(xlFilename),'Sheet',2,'Range','E1');%cell length
writematrix(total_int,string(xlFilename),'Sheet',3,'Range','A1');%total filament intensity
writematrix(total_int_cell,string(xlFilename),'Sheet',4,'Range','A1');%total cell intensity

%% Heatmap of all the cells placed adjacent to one another;
%change z to required sample number

var10=0;
for var13 = im_data(1):im_data(end) %representing the desired frames
    for x = 1:cols
        if var5 == 1
            imagesc_file(:, x) = newtemp6(:,x, var13);
        else
            imagesc_file(:, ((var10*cols)+x+1)) = newtemp6(:,x, var13); %joining all the aligned cells next to one another
        end
    end
    var10 = var10+1;
end
saved_file = imagesc_file;
var13=im_data(1):im_data(end); 
%figure; %imagesc(saved_file); %uncomment to view heatmap
var10=0;
for var13 = im_data(1):im_data(end) %representing the desired frames
    for x = 1:cols
        if var5 == 1
            imagesc_file_loc(:, x) = newtemp6_thresholded(:,x, var13);
        else
            imagesc_file_loc(:, ((var10*cols)+x+1)) = newtemp6_thresholded(:,x, var13); %joining all the aligned cells next to one another
        end
    end
    var10 = var10+1;
end
saved_file_loc = imagesc_file_loc;
var13=im_data(1):im_data(end); 
figure; imagesc(saved_file_loc)
thresh_image = double(saved_file_loc);
thresh_image(thresh_image == 0) = NaN;
low = min(thresh_image, [], 'all')+1;
imagesc(thresh_image);
cmap = jet(max(thresh_image(:)));
cmap(1,:) = zeros(1,3);
colormap(cmap);
set(gca,'XTick',[0:size(((newtemp6_thresholded/2)*3),2):size(thresh_image,2)])
set(gca,'YTick',[])% Remove the ticks in the x axis!
saveas(gcf,['kymo_crop_loc_',num2str(c)],'fig')
colormap jet

%% Filling in holes with averaged pixel values; #aesthtics
% select section and press -> ctrl+t to uncomment;
% select section and press -> ctrl+r to comment;

for var7 = 2 : size(imagesc_file,2) % goes though each column of the concatenated image file
    temp8 = imagesc_file(:,var7);
    [row_idx, ~] = find(temp8);

    for var8 = min(row_idx):max(row_idx)
        if imagesc_file(var8, var7) == 0
            up = imagesc_file(var8-1, var7);
            down = imagesc_file(var8+1, var7);
            right = imagesc_file(var8, var7+1);
            left = imagesc_file(var8, var7-1);
            A = [up, down, right, left]; % neighboring pixel values
            imagesc_file(var8, var7) = ceil(mean(nonzeros(A))); % considers only the pixels that have values
        end
    end
end

figure; 
imagesc(imagesc_file);
colormap jet
thresh_image_full = double(imagesc_file);
thresh_image_full(thresh_image_full == 0) = NaN;
low = min(thresh_image_full, [], 'all')+1;
imagesc(thresh_image_full);
cmap = jet(max(thresh_image_full(:)));
cmap(1,:) = zeros(1,3);
colormap(cmap);
set(gca,'XTick',[]) % Remove the ticks in the x axis!
set(gca,'YTick',[]) % Remove the ticks in the y axis

set(gca,'Position',[0 0 1 1]) % Make the axes occupy the hole figure
saveas(gcf,['kymo_crop_',num2str(c)],'fig')
